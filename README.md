- Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?
  - The Gaming Room asked me to design a cross-platform game: *Draw It or Lose It!*. They required the software to:
    - let multiple teams play a game,
    - allow multiple players on a team,
    - give unique identifiers to teams and games,
    - have a maximum of one instance of a game at one time. 
- What did you do particularly well in developing this documentation?
  - I detailed the client-server model as well as the domain model exceptionally, in my opinion. As someone who plays their fair share of first-person-shooters, I was invested in learning about the client-server model. I feel one step closer to writing my own UDP so that I can make a small MMO game one day. 
- What about the process of working through a design document did you find helpful when developing the code?
  - Writing in a design document was helpful when developing the code because it kept things more linear. On personal projects, I sometimes get quite sporadic with changes, making a bunch of small changes in a ton of different places. This document kept me on track. I think it was because it forced me to research something before getting ahead of myself. Rather than relying on the editor to give me the right autocomplete suggestions, I found myself searching wikis and man pages regarding Jersey.
- If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?
  - If I had the time, I would revise the Recommendations section. I got some wires crossed and began referring to the Java platform as an operating system, rather than a java platform for producing clients that are cross-platform. I should have clarified that I was suggesting this platform so that the client doesn't depend on a specific OS. However, I did clearly recommend a linux distribution for the server(s). I'm not sure which distribution is most commonly used for servers, there is likely one out there specifically for that purpose. Perhaps that's another area I could have invested more time in as well.
- How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?
  - It's important to consider the user's needs when designing software because this is the actual experience derived from writing all of that code. I think of it like this, people don't really care about paint, they care about paintings. In other words, you don't install software based on how pretty and organized the codebase is, you install it for the user experience.
  - That said, looks aren't everything. Just the other day I uninstalled CurseForge in favor of Prism, two tools for modding Minecraft. The former had a beautiful UI, but few customization options. The latter, on the other hand, allowed me to choose which version of Java to use, how much memory to allocate, and so much more I can't even understand (yet).  
- How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?
  - It's all about the software requirements and the user experience. In order to extrapolate design requirements (architecture) from the software requirements, I studied various programming patterns in order to see which ones fulfill such requirements. That's how I decided to go with a the singleton pattern for the GameService in order to force the program to have no more than one instance of a game running at one time. I also studied the iterator patter, a behavioral design pattern that is useful for organizing data and retrieving it efficiently. I used this pattern to: allow multiple teams to play a game, allow multiple players on a team, and even give unique identifiers to teams and games. In the future, I won't have to study these specific patterns as much, but there may be other patterns I'm not familiar with yet. At least now I know the various keywords to use when studying these patterns (i.e. behavioral patters, architecture patterns, etc.). 
